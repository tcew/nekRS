#if p_knl==0
#define ellipticPartialAxHex3D_v0 ellipticPartialAxHex3D
#elif p_knl==1
#define ellipticPartialAxHex3D_v1 ellipticPartialAxHex3D
#elif p_knl==2
#define ellipticPartialAxHex3D_v2 ellipticPartialAxHex3D
#elif p_knl==3 && p_Nq < 11
#define ellipticPartialAxHex3D_v3 ellipticPartialAxHex3D
#elif p_knl==4
#define ellipticPartialAxHex3D_v4 ellipticPartialAxHex3D
#elif p_knl==5
#define ellipticPartialAxHex3D_v5 ellipticPartialAxHex3D
#elif p_knl==6
#define ellipticPartialAxHex3D_v6 ellipticPartialAxHex3D
#elif p_knl==7
#define ellipticPartialAxHex3D_v7 ellipticPartialAxHex3D
#elif p_knl==8
#define ellipticPartialAxHex3D_v8 ellipticPartialAxHex3D
#endif


@kernel void referenceImplementation(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq)
{
  for(dlong e = 0; e < Nelements; ++e; @outer(0)) {

#if defined(FP32) && defined(gfxXX)
    @shared dfloat s_D[p_Nq][p_Nq];
#elif (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq+1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq];
    @exclusive dfloat r_Aq[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    for(int j = 0; j < p_Nq; ++j; @inner(1))
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[p_Nq * j + i];
        element = elementList[e];
      }

    @barrier("local");

    for(int j = 0; j < p_Nq; ++j; @inner(1)) {
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for(int k = 0; k < p_Nq; k++) {
          const dlong base = i + j * p_Nq + element * p_Np;
          r_q[k] = q[base + k * p_Nq * p_Nq];
          r_Aq[k] = 0;
        }
      }
    }

    @barrier("local");

#pragma unroll p_Nq
    for(int k = 0; k < p_Nq; k++) {
      @barrier("local");
      for(int j = 0; j < p_Nq; ++j; @inner(1))
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          r_G00 = ggeo[gbase + p_G00ID * p_Np];
          r_G01 = ggeo[gbase + p_G01ID * p_Np];
          r_G02 = ggeo[gbase + p_G02ID * p_Np];

          r_G11 = ggeo[gbase + p_G11ID * p_Np];
          r_G12 = ggeo[gbase + p_G12ID * p_Np];
          r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
          r_GwJ = 0;
#else
          r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
        }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          s_q[j][i] = r_q[k];

          r_qt = 0;

#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++)
            r_qt += s_D[k][m] * r_q[m];
        }
      }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          dfloat qr = 0;
          dfloat qs = 0;

#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++) {
            qr += s_D[i][m] * s_q[j][m];
            qs += s_D[j][m] * s_q[m][i];
          }

          s_Gqs[j][i] = (r_G01 * qr + r_G11 * qs + r_G12 * r_qt);
          s_Gqr[j][i] = (r_G00 * qr + r_G01 * qs + r_G02 * r_qt);

          const dfloat lambda0 = lambda[0*loffset];

          r_Gqt = lambda0*(r_G02 * qr + r_G12 * qs + r_G22 * r_qt);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          const dfloat lambda1 = lambda[1*loffset];
          r_Auk = r_GwJ * lambda1 * r_q[k];
#endif
        }
      }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++) {
            r_Auk   += s_D[m][j] * s_Gqs[m][i];
            r_Aq[m] += s_D[k][m] * r_Gqt;
            r_Auk   += s_D[m][i] * s_Gqr[j][m];
          }

          r_Aq[k] += r_Auk;
        }
      }
    }

    @barrier("local");

    for(int j = 0; j < p_Nq; ++j; @inner(1)) {
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for(int k = 0; k < p_Nq; k++) {
          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          Aq[id] = r_Aq[k];
        }
      }
    }
  }
}

// original kernel
@kernel void ellipticPartialAxHex3D_v0(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq)
{
  for(dlong e = 0; e < Nelements; ++e; @outer(0)) {

#if defined(FP32) && defined(gfxXX)
    @shared dfloat s_D[p_Nq][p_Nq];
#elif (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq+1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq];
    @exclusive dfloat r_Aq[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    for(int j = 0; j < p_Nq; ++j; @inner(1))
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[p_Nq * j + i];
        element = elementList[e];
      }

    @barrier("local");

    for(int j = 0; j < p_Nq; ++j; @inner(1)) {
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for(int k = 0; k < p_Nq; k++) {
          const dlong base = i + j * p_Nq + element * p_Np;
          r_q[k] = q[base + k * p_Nq * p_Nq];
          r_Aq[k] = 0;
        }
      }
    }

    @barrier("local");

#pragma unroll p_Nq
    for(int k = 0; k < p_Nq; k++) {
      @barrier("local");
      for(int j = 0; j < p_Nq; ++j; @inner(1))
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          r_G00 = ggeo[gbase + p_G00ID * p_Np];
          r_G01 = ggeo[gbase + p_G01ID * p_Np];
          r_G02 = ggeo[gbase + p_G02ID * p_Np];

          r_G11 = ggeo[gbase + p_G11ID * p_Np];
          r_G12 = ggeo[gbase + p_G12ID * p_Np];
          r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
          r_GwJ = 0;
#else
          r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
        }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          s_q[j][i] = r_q[k];

          r_qt = 0;

#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++)
            r_qt += s_D[k][m] * r_q[m];
        }
      }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          dfloat qr = 0;
          dfloat qs = 0;

#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++) {
            qr += s_D[i][m] * s_q[j][m];
            qs += s_D[j][m] * s_q[m][i];
          }

          s_Gqs[j][i] = (r_G01 * qr + r_G11 * qs + r_G12 * r_qt);
          s_Gqr[j][i] = (r_G00 * qr + r_G01 * qs + r_G02 * r_qt);

          const dfloat lambda0 = lambda[0*loffset];

          r_Gqt = lambda0*(r_G02 * qr + r_G12 * qs + r_G22 * r_qt);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          const dfloat lambda1 = lambda[1*loffset];
          r_Auk = r_GwJ * lambda1 * r_q[k];
#endif
        }
      }

      @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
          for(int m = 0; m < p_Nq; m++) {
            r_Auk   += s_D[m][j] * s_Gqs[m][i];
            r_Aq[m] += s_D[k][m] * r_Gqt;
            r_Auk   += s_D[m][i] * s_Gqr[j][m];
          }

          r_Aq[k] += r_Auk;
        }
      }
    }

    @barrier("local");

    for(int j = 0; j < p_Nq; ++j; @inner(1)) {
      for(int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for(int k = 0; k < p_Nq; k++) {
          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          Aq[id] = r_Aq[k];
        }
      }
    }
  }
}


// base version from hipBone

//padding for bank conflicts
#if p_Nq==16
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq==16 || p_Nq==14 || p_Nq==12 || p_Nq==10 || p_Nq==8 || p_Nq==6 || p_Nq==4
#define p_pad 0
#else
#define p_pad 1
#endif


@kernel void ellipticPartialAxHex3D_v1(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq){

  for(dlong e=0; e<Nelements; e++; @outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_Nq][p_Nq+p_pad];
    @shared dfloat s_v[p_Nq][p_Nq+p_pad];
    @shared dfloat s_w[p_Nq][p_Nq+p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong element;

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){

        //load D into local memory
        // s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq*j+i];// D is column major

        element = elementList[e];

        const dlong base = i + j*p_Nq + element*p_Np;

        // load pencil of u into register
        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          const dlong id = base + k*p_Nq*p_Nq;
          r_u[k] = (id!=-1) ? q[id] : 0.0;
        }

        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          r_Au[k] = 0.0;
        }
      }
    }

    // Layer by layer
#ifdef smXX
    // only force some type of unrolling in CUDA mode
    #pragma unroll p_Nq
#endif
    for(int k = 0;k < p_Nq; k++){

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          // share u(:,:,k)
          s_q[j][i] = r_u[k];
        }
      }

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          // prefetch geometric factors
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          const dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          const dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          const dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];

          const dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          const dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          const dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
          const dfloat r_GwJ = 0;
#else
          const dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif

          dfloat ur = 0.f;
          dfloat us = 0.f;
          dfloat ut = 0;

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            ut += s_D[k][m]*r_u[m];
          }

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            ur   += s_D[i][m]*s_q[j][m];
            us   += s_D[j][m]*s_q[m][i];
          }

          const dfloat lambda0 = lambda[0*loffset];

          s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*ut);
          s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*ut);
          r_GDut    = lambda0*(r_G02*ur + r_G12*us + r_G22*ut);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          r_Auk = r_GwJ*lambda[1*loffset]*r_u[k];
#endif
        }
      }

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            r_Au[m] += s_D[k][m]*r_GDut;
          }

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            r_Auk += s_D[m][j]*s_w[m][i];
            r_Auk += s_D[m][i]*s_v[j][m];
          }

          r_Au[k] += r_Auk;
        }
      }
    } //end Layer by layer

    // write out
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const dlong id = element*p_Np + j*p_Nq + i;

        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          Aq[id+k*p_Nq*p_Nq] = r_Au[k];
        }
      }
    }
  }
}

#if defined(FP32)
// from FDM kernel...
// need to use this for FP32...
#if p_Nq==2
#define p_NelementsPerBlk 63
#elif p_Nq==3
#define p_NelementsPerBlk 27
#elif p_Nq==4
#define p_NelementsPerBlk 15
#elif p_Nq==5
#define p_NelementsPerBlk 9
#elif p_Nq==6
#define p_NelementsPerBlk 7
#elif p_Nq==7
#define p_NelementsPerBlk 5
#elif p_Nq==8
#define p_NelementsPerBlk 5
#elif p_Nq==9
#define p_NelementsPerBlk 3
#elif p_Nq==10
#define p_NelementsPerBlk 5
#elif p_Nq==11
#define p_NelementsPerBlk 3
#elif p_Nq==12
#define p_NelementsPerBlk 3
#elif p_Nq==13
#define p_NelementsPerBlk 3
#elif p_Nq==14
#define p_NelementsPerBlk 3
#elif p_Nq==15
#define p_NelementsPerBlk 3
#else
#define p_NelementsPerBlk 1
#endif

#else

// 2D, blocked version
#if p_N==1
#define p_NelementsPerBlk 16
#elif p_N==2
#define p_NelementsPerBlk 56
#elif p_N==3
#define p_NelementsPerBlk 32
#elif p_N==4
#define p_NelementsPerBlk 5
#elif p_N==5
#define p_NelementsPerBlk 1
#elif p_N==6
#define p_NelementsPerBlk 5
#elif p_N==7
#define p_NelementsPerBlk 1
#elif p_N==8
#define p_NelementsPerBlk 3
#elif p_N==9
#define p_NelementsPerBlk 1
#elif p_N==10
#define p_NelementsPerBlk 1
#elif p_N==11
#define p_NelementsPerBlk 1
#elif p_N==12
#define p_NelementsPerBlk 1
#elif p_N==13
#define p_NelementsPerBlk 1
#elif p_N==14
#define p_NelementsPerBlk 1
#elif p_N==15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

#endif

//padding for bank conflicts
#if p_Nq==16
#define p_pad 1
#else
#define p_pad 0
#endif

@kernel void ellipticPartialAxHex3D_v2(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq){

  for(dlong eo=0; eo<Nelements; eo+=p_NelementsPerBlk; @outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_NelementsPerBlk][p_Nq][p_Nq+p_pad];
    @shared dfloat s_v[p_NelementsPerBlk][p_Nq][p_Nq+p_pad];
    @shared dfloat s_w[p_NelementsPerBlk][p_Nq][p_Nq+p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          //load D into local memory
          // s_D[i][j] = d \phi_i at node j
          if (es==0) {
            s_D[j][i] = D[p_Nq*j+i];// D is column major
          }

          r_e = es+eo;

          if(r_e<Nelements){
            element = elementList[r_e];

            const dlong base = i + j*p_Nq + element*p_Np;

            // load pencil of u into register
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              const dlong id = base + k*p_Nq*p_Nq;
              r_u[k] = (id!=-1) ? q[id] : 0.0;
            }

            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
    // only force some type of unrolling in CUDA mode
    #pragma unroll p_Nq
#endif
#ifdef gfxXX
    // on HIP, tell the compiler to not unroll this loop
    #pragma nounroll
#endif
    for(int k = 0;k < p_Nq; k++){

      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){
            // share u(:,:,k)
            s_q[es][j][i] = r_u[k];
          }
        }
      }

      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

            if(r_e<Nelements){
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];

              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
              r_GwJ = 0;
#else
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ut += s_D[k][m]*r_u[m];
            }

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ur   += s_D[i][m]*s_q[es][j][m];
              us   += s_D[j][m]*s_q[es][m][i];
            }

            const dfloat lambda0 = lambda[0*loffset];

            s_w[es][j][i] = (r_G01*ur + r_G11*us + r_G12*ut);
            s_v[es][j][i] = (r_G00*ur + r_G01*us + r_G02*ut);
            r_GDut        = lambda0*(r_G02*ur + r_G12*us + r_G22*ut);

#ifdef p_poisson
          r_Auk = 0.0;
#else
          const dfloat lambda1 = lambda[1*loffset];
          r_Auk = r_GwJ * lambda1 * r_u[k];
#endif
          }
        }
      }

      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Au[m] += s_D[k][m]*r_GDut;
            }

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Auk   += s_D[m][j]*s_w[es][m][i];
              r_Auk   += s_D[m][i]*s_v[es][j][m];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } //end Layer by layer

    // write out
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          if(r_e<Nelements){
            const dlong id = element*p_Np + j*p_Nq + i;

            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              Aq[id+k*p_Nq*p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}

// 3D thread structure, good for low orders
#if p_Nq < 11

#if defined(FP32)
// from FDM kernel
#if p_Nq==2
#define p_NelementsPerBlk 63
#elif p_Nq==3
#define p_NelementsPerBlk 27
#elif p_Nq==4
#define p_NelementsPerBlk 15
#elif p_Nq==5
#define p_NelementsPerBlk 8
#elif p_Nq==6
#define p_NelementsPerBlk 4
#elif p_Nq==7
#define p_NelementsPerBlk 2
#elif p_Nq==8
#define p_NelementsPerBlk 2
#else
#define p_NelementsPerBlk 1
#endif

#else

#if p_N==1
#define p_NelementsPerBlk 8
#elif p_N==2
#define p_NelementsPerBlk 4
#elif p_N==3
#define p_NelementsPerBlk 2
#elif p_N==4
#define p_NelementsPerBlk 1
#elif p_N==5
#define p_NelementsPerBlk 1
#elif p_N==6
#define p_NelementsPerBlk 1
#elif p_N==7
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

#endif

@kernel void ellipticPartialAxHex3D_v3(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq)
{
//padding for bank conflicts
#if (p_Nq==8 || p_Nq==4) && defined(smXX)
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq==16 || p_Nq==14 || p_Nq==12 || p_Nq==8 || p_Nq==6 || p_Nq==4
#define p_pad 0
#else
#define p_pad 1
#endif



  for(int eo=0;eo<Nelements;eo+=p_NelementsPerBlk;@outer(0)){

    @shared dfloat s_D [p_Nq][p_Nq+p_pad];
    @shared dfloat s_DT[p_Nq][p_Nq+p_pad];
    @shared dfloat   s_q[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq+p_pad];
    @shared dfloat s_Gqr[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq+p_pad];
    @shared dfloat s_Gqs[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq+p_pad];
    @shared dfloat s_Gqt[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq+p_pad];

    @exclusive dlong element;
    @exclusive dfloat r_wJ;

    @exclusive int k, es;

    for(int ke=0;ke<p_Nq*p_NelementsPerBlk;++ke;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          //load operators
          if(ke==0){
            const int id = j*p_Nq+i;
            const dfloat Dji = D[id];
            s_D[j][i] = Dji;
            s_DT[i][j] = Dji;
          }

          k  = ke%p_Nq;
          es = ke/p_Nq;
          dlong r_e = es+eo;
	  element = (r_e<Nelements) ? elementList[r_e]:-1;
          if(element!=-1){
            const dlong id = i + j*p_Nq + k*p_Nq*p_Nq + element*p_Np;
            if (id!=-1)
              s_q[es][k][j][i] = q[id];
            else
              s_q[es][k][j][i] = 0.0;
          }
        }
      }
    }

    for(int ke=0;ke<p_Nq*p_NelementsPerBlk;++ke;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          if(element!=-1){

            // 't' terms
            dfloat tmp=0.0;

            const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

            const dfloat G00 = ggeo[gbase + p_G00ID * p_Np];
            const dfloat G01 = ggeo[gbase + p_G01ID * p_Np];
            const dfloat G02 = ggeo[gbase + p_G02ID * p_Np];

            const dfloat G11 = ggeo[gbase + p_G11ID * p_Np];
            const dfloat G12 = ggeo[gbase + p_G12ID * p_Np];
            const dfloat G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
            const dfloat r_wJ = 0;
#else
            const dfloat r_wJ = ggeo[gbase + p_GWJID * p_Np];
#endif

            // #pragma unroll p_Unr
            for(int m = 0; m < p_Nq; ++m) {
              const dfloat pmji = s_q[es][m][j][i];
              const dfloat Dkm = s_DT[m][k];
              tmp += Dkm*pmji;
            }


            s_Gqr[es][k][j][i] = G02*tmp;
            s_Gqs[es][k][j][i] = G12*tmp;
            s_Gqt[es][k][j][i] = G22*tmp;


            // 'r' terms
            tmp = 0;
            // #pragma unroll p_Unr
            for(int m = 0; m < p_Nq; ++m) {
              const dfloat Dim = s_D[i][m];
              tmp += Dim*s_q[es][k][j][m];
            }

            s_Gqr[es][k][j][i] += G00*tmp;
            s_Gqs[es][k][j][i] += G01*tmp;
            s_Gqt[es][k][j][i] += G02*tmp;


            // 's' terms
            tmp = 0;
            // #pragma unroll p_Unr
            for(int m = 0; m < p_Nq; ++m) {
              const dfloat Djm = s_D[j][m];
              tmp += Djm*s_q[es][k][m][i];
            }

            s_Gqr[es][k][j][i] += G01*tmp;
            s_Gqs[es][k][j][i] += G11*tmp;
            s_Gqt[es][k][j][i] += lambda[0*loffset]*G12*tmp;
          }
        }
      }
    }

    for(int ke=0;ke<p_Nq*p_NelementsPerBlk;++ke;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          if(element!=-1){
#ifdef p_poisson
            dfloat tmpAp = 0.0;
#else
            dfloat tmpAp = s_q[es][k][j][i]*lambda[1*loffset]*r_wJ;
#endif

            // use same matrix for both slices
            // #pragma unroll p_Unr
            for(int m=0;m<p_Nq;++m){
              const dfloat Dmi = s_D[m][i];
              const dfloat Dmj = s_D[m][j];

              tmpAp += Dmi*s_Gqr[es][k][j][m];
              tmpAp += Dmj*s_Gqs[es][k][m][i];
            }

            // #pragma unroll p_Unr
            for(int m=0;m<p_Nq;++m){
              const dfloat Gpt = s_Gqt[es][m][j][i];
              const dfloat Dmk = s_D[m][k];
              tmpAp += Dmk*Gpt;
            }

            const dlong base = i + j*p_Nq + k*p_Nq*p_Nq + element*p_Np;
            Aq[base] = tmpAp;
          }
        }
      }
    }
  }
}
#endif


//padding for bank conflicts
#if p_Nq==16
#define p_pad 1
#else
#define p_pad 0
#endif


#if p_Nq==3
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq==4
#define p_NelementsPerBlk 31
#elif p_Nq==5
#define p_NelementsPerBlk 19
#define p_pad 1
#elif p_Nq==6
#define p_NelementsPerBlk 7
#elif p_Nq==7
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq==8
#define p_NelementsPerBlk 3
#elif p_Nq==9
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq==10
#define p_NelementsPerBlk 3
#elif p_Nq==11
// tuned
#define p_NelementsPerBlk 2
#define p_pad 1
#elif p_Nq==12
// was 3 no pad
#define p_NelementsPerBlk 3
#elif p_Nq==13
#define p_NelementsPerBlk 3
// why on earth
#define p_pad 1
#elif p_Nq==14
#define p_NelementsPerBlk 3
#elif p_Nq==15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif


@kernel void ellipticPartialAxHex3D_v4(const dlong Nelements,
				       const dlong offset,
				       const dlong loffset,
				       @restrict const dlong*  elementList,
				       @restrict const dfloat* ggeo,
				       @restrict const dfloat* D,
				       @restrict const dfloat* S,
				       @restrict const dfloat* lambda,
				       @restrict const dfloat* q,
				       @restrict       dfloat* Aq){
  
  for(dlong eo=0; eo<Nelements; eo+=p_NelementsPerBlk; @outer(0)){
    
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_v[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_w[p_Nq][p_Nq][p_NelementsPerBlk];

    @exclusive dfloat r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          //load D into local memory
          // s_D[i][j] = d \phi_i at node j
          if (es==0) {
            s_D[j][i] = D[p_Nq*j+i];// D is column major
          }

          r_e = es+eo;

          if(r_e<Nelements){
            element = elementList[r_e];

            const dlong base = i + j*p_Nq + element*p_Np;

            // load pencil of u into register
#pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              const dlong id = base + k*p_Nq*p_Nq;
              r_u[k] = (id!=-1) ? q[id] : 0.0;
            }

#pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
    // only force some type of unrolling in CUDA mode
    #pragma unroll p_Nq
#endif
#ifdef gfxXX
    // on HIP, tell the compiler to not unroll this loop
    #pragma nounroll
#endif
    for(int k = 0;k < p_Nq; k++){

      @barrier();
      
      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){
            // share u(:,:,k)
            s_q[j][i][es] = r_u[k];
          }
        }
      }

      @barrier();

      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

            if(r_e<Nelements){
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];

              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
              r_GwJ = 0;
#else
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

#pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ur   += s_D[i][m]*s_q[j][m][es];
              us   += s_D[j][m]*s_q[m][i][es];
            }

            const dfloat lambda0 = lambda[0*loffset];

#pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ut += s_D[k][m]*r_u[m];
            }
	    
            s_w[j][i][es] = (r_G01*ur + r_G11*us + r_G12*ut);
            s_v[j][i][es] = (r_G00*ur + r_G01*us + r_G02*ut);
            pfloat r_GDut        = lambda0*(r_G02*ur + r_G12*us + r_G22*ut);

#pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Au[m] += s_D[k][m]*r_GDut;
            }
	    
#ifdef p_poisson
	    r_Auk = 0.0;
#else
	    const dfloat lambda1 = lambda[1*loffset];
	    r_Auk = r_GwJ * lambda1 * r_u[k];
#endif
          }
        }
      }

      @barrier();
      
      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

#pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Auk   += s_D[m][j]*s_w[m][i][es];
              r_Auk   += s_D[m][i]*s_v[j][m][es];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } //end Layer by layer

    // write out
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          if(r_e<Nelements){
            const dlong id = element*p_Np + j*p_Nq + i;

            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              Aq[id+k*p_Nq*p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}



@kernel void ellipticPartialAxHex3D_v5(const dlong Nelements,
				       const dlong offset,
				       const dlong loffset,
				       @restrict const dlong*  elementList,
				       @restrict const dfloat* ggeo,
				       @restrict const dfloat* D,
				       @restrict const dfloat* S,
				       @restrict const dfloat* lambda,
				       @restrict const dfloat* q,
				       @restrict       dfloat* Aq){
  
  for(dlong eo=0; eo<Nelements; eo+=p_NelementsPerBlk; @outer(0)){
    
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_v[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_w[p_Nq][p_Nq][p_NelementsPerBlk];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          //load D into local memory
          // s_D[i][j] = d \phi_i at node j
          if (es==0) {
            s_D[j][i] = D[p_Nq*j+i];// D is column major
          }

          r_e = es+eo;

          if(r_e<Nelements){
            element = elementList[r_e];

            const dlong base = i + j*p_Nq + element*p_Np;

            // load pencil of u into register
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              const dlong id = base + k*p_Nq*p_Nq;
              r_u[k] = (id!=-1) ? q[id] : 0.0;
            }

            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
    // only force some type of unrolling in CUDA mode
    #pragma unroll p_Nq
#endif
#ifdef gfxXX
    // on HIP, tell the compiler to not unroll this loop
    #pragma nounroll
#endif
    for(int k = 0;k < p_Nq; k++){

      @barrier();
      
      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){
            // share u(:,:,k)
            s_q[j][i][es] = r_u[k];
          }
        }
      }

      @barrier();

      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

            if(r_e<Nelements){
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + p_Nggeo*(k * p_Nq * p_Nq + j * p_Nq + i);

              r_G00 = ggeo[gbase + p_G00ID];
              r_G01 = ggeo[gbase + p_G01ID];
              r_G02 = ggeo[gbase + p_G02ID];

              r_G11 = ggeo[gbase + p_G11ID];
              r_G12 = ggeo[gbase + p_G12ID];
              r_G22 = ggeo[gbase + p_G22ID];

#ifdef p_poisson
              r_GwJ = 0;
#else
              r_GwJ = ggeo[gbase + p_GWJID];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ur   += s_D[i][m]*s_q[j][m][es];
              us   += s_D[j][m]*s_q[m][i][es];
            }

            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              ut += s_D[k][m]*r_u[m];
            }
	    
            const dfloat lambda0 = lambda[0*loffset];

            s_w[j][i][es] = (r_G01*ur + r_G11*us + r_G12*ut);
            s_v[j][i][es] = (r_G00*ur + r_G01*us + r_G02*ut);
            r_GDut        = lambda0*(r_G02*ur + r_G12*us + r_G22*ut);

#pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Au[m] += s_D[k][m]*r_GDut;
            }

	    
#ifdef p_poisson
          r_Auk = 0.0;
#else
          const dfloat lambda1 = lambda[1*loffset];
          r_Auk = r_GwJ * lambda1 * r_u[k];
#endif
          }
        }
      }

      @barrier();
      
      for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){


            #pragma unroll p_Nq
            for (int m=0;m<p_Nq;m++) {
              r_Auk   += s_D[m][j]*s_w[m][i][es];
              r_Auk   += s_D[m][i]*s_v[j][m][es];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } //end Layer by layer

    // write out
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          if(r_e<Nelements){
            const dlong id = element*p_Np + j*p_Nq + i;

            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              Aq[id+k*p_Nq*p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}


//padding for bank conflicts
#if p_Nq==16
#define p_pad 1
#else
#define p_pad 0
#endif


#if p_Nq==3
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq==4
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq==5
#define p_NelementsPerBlk 19
#define p_pad 1
#elif p_Nq==6
#define p_NelementsPerBlk 7
#elif p_Nq==7
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq==8
#define p_NelementsPerBlk 3
#elif p_Nq==9
#define p_NelementsPerBlk 3
#define p_pad 1
#elif p_Nq==10
#define p_NelementsPerBlk 3
#define p_pad 0
#elif p_Nq==11
// tuned
#define p_NelementsPerBlk 2
#define p_pad 1
#elif p_Nq==12
// was 3 no pad
#define p_NelementsPerBlk 3
#elif p_Nq==13
#define p_NelementsPerBlk 3
// why on earth
#define p_pad 1
#elif p_Nq==14
#define p_NelementsPerBlk 3
#elif p_Nq==15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif


@kernel void ellipticPartialAxHex3D_v6(const dlong Nelements,
				       const dlong offset,
				       const dlong loffset,
				       @restrict const dlong*  elementList,
				       @restrict const dfloat* ggeo,
				       @restrict const dfloat* D,
				       @restrict const dfloat* S,
				       @restrict const dfloat* lambda,
				       @restrict const dfloat* q,
				       @restrict       dfloat* Aq){
  
  for(dlong eo=0; eo<Nelements; eo+=p_NelementsPerBlk; @outer(0)){
    
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_Nq][p_Nq][p_Nq][p_NelementsPerBlk];
    
    @exclusive dlong r_e, element;
    
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          //load D into local memory
          // s_D[i][j] = d \phi_i at node j
          if (es==0) {
            s_D[j][i] = D[p_Nq*j+i];// D is column major
          }

          r_e = es+eo;

          if(r_e<Nelements){
            element = elementList[r_e];

            const dlong base = i + j*p_Nq + element*p_Np;

            // load pencil of u into register
#pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              const dlong id = base + k*p_Nq*p_Nq;
              s_q[k][j][i][es] = (id!=-1) ? q[id] : 0.0;
            }
          }
        }
      }
    }
    
    @barrier();
    
    @exclusive dfloat qr[p_Nq], qs[p_Nq], qt[p_Nq];

    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  
	  for(int n=0;n<p_Nq;++n){
	    qr[n] = 0; qs[n] = 0; qt[n] = 0;
	  }

#define p_halfNq (p_Nq/2)
	  
#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
	    dfloat qnji1 = s_q[n][j][i][es];
	    dfloat qnji2 = s_q[p_Nq-1-n][j][i][es];
#pragma unroll
	    for(int k=0;k<p_halfNq;++k){
	      dfloat Dkn = s_D[k][n];
	      qt[k] += Dkn*qnji1;
	      qt[p_Nq-1-k] -= Dkn*qnji2;
	    }
	  }
	  
#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
	    dfloat Din = s_D[i][n];
#pragma unroll p_Nq
	    for(int k=0;k<p_Nq;++k){
	      qr[k] += Din*s_q[k][j][n][es];
	    }
	  }

#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
	    dfloat Djn = s_D[j][n];
#pragma unroll p_Nq
	    for(int k=0;k<p_Nq;++k){
	      qs[k] += Djn*s_q[k][n][i][es];
	    }
	  }
	  
	  if(r_e<Nelements){
	    dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
	    
#pragma unroll
	    for(int k=0;k<p_Nq;++k){
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
	      
              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];
	      
              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];
	      
#ifdef p_poisson
              r_GwJ = 0;
#else
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
	      dfloat qx = r_G00*qr[k] + r_G01*qs[k] + r_G02*qt[k];
	      dfloat qy = r_G01*qr[k] + r_G11*qs[k] + r_G12*qt[k];
	      dfloat qz = r_G02*qr[k] + r_G12*qs[k] + r_G22*qt[k];
	      
	      qr[k] = qx;
	      qs[k] = qy;
	      qt[k] = qz;
            }
	  }
	}
      }
    }
    
    @barrier();
    
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  for(int k=0;k<p_Nq;++k){
	    s_q[k][j][i][es] = qr[k];
	    qr[k] = 0;
	  }

	  // do 'c' diff
#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
#pragma unroll 
	    for(int k=0;k<p_halfNq;++k){
	      dfloat Dnk = s_D[n][k];
	      qr[k] += Dnk*qt[n];
	      qr[p_Nq-1-k] += Dnk*qt[n];
	    }
	  }
	}
      }
    }
    
    @barrier();
    
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){

	  // do 'a' diff
#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
	    dfloat Din = s_D[n][i];
#pragma unroll p_Nq
	    for(int k=0;k<p_Nq;++k){
	      qr[k] += Din*s_q[k][j][n][es];
	    }
	  }
	}
      }
    }

    @barrier();
    
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  for(int k=0;k<p_Nq;++k){
	    s_q[k][j][i][es] = qs[k];
	  }
	}
      }
    }

    @barrier();
    
    for(int es=0;es<p_NelementsPerBlk;++es;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){

	  // do 'a' diff
#pragma unroll p_Nq
	  for(int n=0;n<p_Nq;++n){
	    dfloat Djn = s_D[n][j];
#pragma unroll p_Nq
	    for(int k=0;k<p_Nq;++k){
	      qr[k] += Djn*s_q[k][n][i][es];
	    }
	  }
	  
          if(r_e<Nelements){
            const dlong id = element*p_Np + j*p_Nq + i;
	    
#pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              Aq[id+k*p_Nq*p_Nq] = qr[k];
            }
          }
        }
      }
    }
  }
}




//padding for bank conflicts
#if p_Nq==16 || p_Nq==14 || p_Nq==12 || p_Nq==10 || p_Nq==8 || p_Nq==6 || p_Nq==4
#define p_pad 0
#else
#define p_pad 1
#endif

@kernel void ellipticPartialAxHex3D_v7(const dlong Nelements,
                                    const dlong offset,
                                    const dlong loffset,
                                    @restrict const dlong*  elementList,
                                    @restrict const dfloat* ggeo,
                                    @restrict const dfloat* D,
                                    @restrict const dfloat* S,
                                    @restrict const dfloat* lambda,
                                    @restrict const dfloat* q,
                                    @restrict       dfloat* Aq){

  for(dlong e=0; e<Nelements; e++; @outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_q[p_Nq][p_Nq+p_pad];
    @shared dfloat s_v[p_Nq][p_Nq+p_pad];
    @shared dfloat s_w[p_Nq][p_Nq+p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong element;

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){

        //load D into local memory
        // s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq*j+i];// D is column major

        element = elementList[e];

        const dlong base = i + j*p_Nq + element*p_Np;

        // load pencil of u into register
        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          const dlong id = base + k*p_Nq*p_Nq;
          r_u[k] = (id!=-1) ? q[id] : 0.0;
        }

        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          r_Au[k] = 0.0;
        }
      }
    }

    // Layer by layer
#ifdef smXX
    // only force some type of unrolling in CUDA mode
    #pragma unroll p_Nq
#endif
    for(int k = 0;k < p_Nq; k++){

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          // share u(:,:,k)
          s_q[j][i] = r_u[k];
        }
      }

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          // prefetch geometric factors
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          const dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          const dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          const dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];

          const dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          const dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          const dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifdef p_poisson
          const dfloat r_GwJ = 0;
#else
          const dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif

          dfloat ur = 0.f;
          dfloat us = 0.f;
          dfloat ut = 0;

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            ut += s_D[k][m]*r_u[m];
          }

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            ur   += s_D[i][m]*s_q[j][m];
            us   += s_D[j][m]*s_q[m][i];
          }

          const dfloat lambda0 = lambda[0*loffset];

          s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*ut);
          s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*ut);
          r_GDut    = lambda0*(r_G02*ur + r_G12*us + r_G22*ut);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          r_Auk = r_GwJ*lambda[1*loffset]*r_u[k];
#endif
        }
      }

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            r_Au[m] += s_D[k][m]*r_GDut;
          }

          #pragma unroll p_Nq
          for (int m=0;m<p_Nq;m++) {
            r_Auk += s_D[m][j]*s_w[m][i];
            r_Auk += s_D[m][i]*s_v[j][m];
          }

          r_Au[k] += r_Auk;
        }
      }
    } //end Layer by layer

    // write out
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const dlong id = element*p_Np + j*p_Nq + i;

        #pragma unroll p_Nq
        for (int k=0;k<p_Nq;k++) {
          Aq[id+k*p_Nq*p_Nq] = r_Au[k];
        }
      }
    }
  }
}
